### LRUCache原理
Lru的全称是Least Recently Used ，近期最少使用的；把近期最少使用的数据从缓存中移除，保留使用最频繁的数据;
其中用到的数据对象是LinkedHashMap

### ThreadLocal 原理
* 作用：ThreadLocal是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。
* 原理：每个线程都会有一个类型为ThreadLocal.ThreadLocalMap的map,这个map就是用来存储与这个线程绑定的变量,map的key就是ThreadLocal对象,value就是线程正在执行的任务中的某个变量的包装类Entry.
* 使用注意：
  * 使用ThreadLocal对象,尽量使用static,不然会使线程的ThreadLocalMap产生太多Entry,从而造成内存泄露
  * 使用weakReference,能够在ThreadLocal失去强引用的时候,ThreadLocal对应的Entry能够在下次gc时被回收,回收后的空间能够得到复用,在一定程度下能够避免内存泄露.
 set(null)把当前的ThreadLocal为key的值设为了空,避免线程下次再执行其他任务时被使用,但此时这个key对应的Entry值还在,只是Entry.value=null
 remove方法会把这个key对应Entry的值设为空
从重用和效率的角度来说,set(null)的性能优于remove,在实际的项目中推荐使用set(null)来回收ThreadLocal设置的值.


### 数据结构中堆的概念，堆排序
* 内存中也有一块叫做堆的存储区域，但是这与数据结构中的堆是完全不同的概念。
* 因为堆是一棵完全二叉树，所以我们可以用顺序表来实现，而且堆也只能用顺序表。可以用vector来实现。
* 实现：若在输出堆顶的最小值之后，使得剩余n-1个元素的序列重又建成一个堆，则得到n个元素的次小值。如此反复执行，便能得到一个有序序列，这个过程称之为堆排序。
* 应用：在一个n个数的序列中取其中最大的k个数（Top k问题）。

### JVM内存模型（https://blog.csdn.net/u010425776/article/details/51170118）
##### 程序计数器 
* 也就是说，程序计数器里面记录的是当前线程正在执行的那一条字节码指令的地址；
* 线程私有，每个线程都有自己的计数器;
* 是唯一一个不会出现OOM的内存区域；
* 生命周期跟随线程；
##### Java虚拟机栈 
* Java虚拟机栈会为每一个即将运行的Java方法创建一块叫做“栈帧”的区域，这块区域用于存储该方法在运行过程中所需要的一些信息，这些信息包括：
   * 局部变量表 
   * 操作数栈
   * 动态链接
   * 方法出口信息
> 注意：
人们常说，Java的内存空间分为“栈”和“堆”，栈中存放局部变量，堆中存放对象。  但这里的“栈”只代表了Java虚拟机栈中的局部变量表部分。真正的Java虚拟机栈是由一个个栈帧组成。
Java虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。
* StackOverFlowError（堆栈溢出）表示当前线程申请的栈超过了事先定好的栈的最大深度，但内存空间可能还有很多。 
* OutOfMemoryError（内存溢出）是指当线程申请栈时发现栈已经满了，而且内存也全都用光了。
* Memory leak（内存泄漏）：是指程序在申请内存后，无法释放已申请的内存空间。最终会导致内存溢出。

##### 本地方法栈  在很多虚拟机中已经将本地方法栈和虚拟机栈合二为一了；

##### 堆 
* 线程共享  整个Java虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java虚拟机栈、本地方法栈都是一个线程对应一个的
* 在虚拟机启动时创建
* 垃圾回收的主要场所。
* 可以进一步细分为：新生代、老年代。  	新生代又可被分为：Eden、From Survior、To Survior。 

##### 方法区
* 存放已经被虚拟机加载的类信息、常量（存放在运行时常量池中）、静态变量等。 
* 线程共享  方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。
* 永久代  方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，我们把方法区称为老年代。
* 内存回收效率低  方法区中的信息一般需要长期存在，回收一遍内存之后可能只有少量信息无效。  对方法区的内存回收的主要目标是：对常量池的回收 和 对类型的卸载。
* Java虚拟机规范对方法区的要求比较宽松。  和堆一样，允许固定大小，也允许可扩展的大小，还允许不实现垃圾回收。

### 并发集合了解哪些 (https://blog.csdn.net/paincupid/article/details/52017292)
##### ConcurrentHashMap
##### Vector 

### 开启线程的三种方式,run()和start()方法区别
> start()：表示线程已经准备就绪；
> run()：是真正执行线程的方法；

### GC回收策略，能不能显式调用System.gc()
##### 新生代的GC：
新生代通常存活时间较短，因此基于Copying算法来进行回收；
所谓Copying算法就是扫描出存活的对象，并复制到一块新的完全未使用的空间中，对应于新生代，就是在Eden和FromSpace或ToSpace之间copy。
##### 旧生代的GC：
对象存活的时间比较长，比较稳定，因此采用标记(Mark)算法来进行回收（具体实现的是可达性算法）；
所谓标记就是扫描出存活的对象，然后再进行回收未被标记的对象，回收后对用空出的空间要么进行合并，要么标记出来便于下次进行分配，总之就是要减少内存碎片带来的效率损耗。
不推荐显式调用System.gc():
此函数建议JVM进行主GC,虽然只是建议而非一定,但很多情况下它会触发主GC,从而增加主GC的频率,也即增加了间歇性停顿的次数。
##### 可达性算法：
当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的
Java语言里，可作为GC Roots对象的包括如下几种：     
 a.虚拟机栈(栈桢中的本地变量表)中的引用的对象     
 b.方法区中的类静态属性引用的对象     
 c.方法区中的常量引用的对象     
 d.本地方法栈中JNI的引用的对象 
 
### 排序，快速排序的实现


### Java中对象的生命周期
##### 创建阶段(Created)
> 一旦对象被创建，并被分派给某些变量赋值，这个对象的状态就切换到了应用阶段;

##### 应用阶段(In Use)
> 对象至少被一个强引用持有着。

##### 不可见阶段(Invisible)
> 当一个对象处于不可见阶段时，说明程序本身不再持有该对象的任何强引用，虽然该这些引用仍然是存在着的。（该对象仍可能被静态变量或线程或JNI等强引用持有着）
简单说就是程序的执行已经超出了该对象的作用域了。

##### 不可达阶段(Unreachable)
> 对象处于不可达阶段是指该对象不再被任何强引用所持有。

##### 收集阶段(Collected)
> 当垃圾回收器发现该对象已经处于“不可达阶段”并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，则对象进入了“收集阶段”。如果该对象已经重写了finalize()方法，则会去执行该方法的终端操作。（不推荐重写finalize()方法）

##### 终结阶段(Finalized)
> 当对象执行完finalize()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段是等待垃圾回收器对该对象空间进行回收。

##### 对象空间重分配阶段(De-allocated)
>垃圾回收器对该对象的所占用的内存空间进行回收或者再分配了，则该对象彻底消失了，称之为“对象空间重新分配阶段”。

### 类加载机制
##### 双亲委派机制
> PathClassLoader，DexClassLoader，dexPathList，Element,

##### 双亲委派模型
* 双亲委托模型就是首先判断该Class是否已经加载，如果没有则不是自身去查找而是委托给父加载器进行查找，这样依次的进行递归，直到委托到最顶层的Bootstrap ClassLoader，如果Bootstrap ClassLoader找到了该Class，就会直接返回，如果还没找到则最后会交由自身（出发点）去查找（并不会向下查找），如果还没找到，则ClassNotFoundException。
* 启动类加载器（Bootstrap ClassLoader）：这是由C++语言实现的一个加载器，是虚拟机的一部分，随虚拟机启动运行。
* 扩展类加载器（Extension ClassLoader）：负责加载/lib/ext目录中的，或者被java.ext.dir系统变量指定路径中的所有类库。
* 应用程序类加载器（Application ClassLoader）：负责加载用户类路径（ClassPath）上所指定的类库，如果程序中没有自定义自己的类加载器，这个就是默认加载器。
##### 双亲委托模型的好处：
* 防止内存中出现多份同样的字节码，比如两个类A和类B都要加载System类：
* 如果不用委托而是自己加载自己的，那么类A就会加载一份System字节码，然后类B又会加载一份System字节码，这样内存中就出现了两份System字节码。


### https相关，如何验证证书的合法性，https中哪里用了对称加密，哪里用了非对称加密，对加密算法（如RSA）等是否有了解
##### 问题域：A与B通信，有且只有A和B能够知道通信内容
> 对称加密（AES或者其他加密算法）：对通信内容进行加密；
##### 问题一：服务器怎么告诉客户端使用哪种加密算法？（通过协商，若协商没有加密，仍然有风险）
> 非对称加密：（RSA或者其他算法）：对对称加密的协商过程进行加密（采用随机数来生成对称加密算法）；
##### 问题二：怎么得到公钥？
> 将公钥放到服务器（有多了一次请求）,服务端将公钥发送给每一个客户端（可行）；
##### 问题三：公钥被掉包了怎么办？
> 使用第三方机构（CA）的公钥解决：“数字证书”中包含了服务器交给第三方的公钥，客户端拿到公钥，如果能解密，说明是服务器返回的，反之，则被掉包了；（第三方机构会使用自己的私钥对服务器的公钥再次加密）
##### 问题四：第三方机构也可以给中间人颁发这样的“数字证书”，这样还是有风险进行掉包？
> 数字签名（数字证书的编号）：在证书上面写着如何生成证书编号。客户端生成编号以后和证书中的编号进行对比；

##### 非对称加密的特点:

### String 为什么要设计成不可变的？
##### 设计考虑：（字符串常量池的需要）
String s1 = “abcd”;
String s2 = “abcd”;
上面的代码只会在堆中生成一个变量；假如String是可变的，一个对象改变了，就会影响到另外的变量；
##### 效率优化：（允许String缓存HashCode）
String的Hash被频繁使用（HashMap），如果String不可变，就保证了Hash的唯一性，不用每次都去缓存；
##### 安全性：
String被许多的Java类(库)用来当做参数,例如 网络连接地址URL,文件路径path,还有反射机制所需要的String参数等, 假若String不是固定不变的,将会引起各种安全隐患。

### String，Stringbuffer 与stringbuilder 的区别？

### java四中引用

Java线程池


线程和进程的区别？为什么要有线程，而不是仅仅用进程？


多线程：怎么用、有什么问题要注意；Android线程有没有上限，然后提到线程池的上限


如何保证多线程读写文件的安全？


如何实现线程同步？


为什么不能在子线程更新UI


算法判断单链表成环与否？


object类的equal和hashcode方法重写，为什么？
HashCode：
hashCode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值 ；

内存泄漏的可能原因？用IDE如何分析内存泄漏？


OOM的可能原因？Oom是否可以try catch？
1.资源对象没关闭造成的内存泄露，try catch finally中将资源回收放到finally语句可以有效避免OOM。资源性对象比如： 	（1）Cursor；
（2）调用registerReceiver后未调用unregisterReceiver()； 	（3）未关闭InputStream/OutputStream； 	（4）Bitmap使用后未调用recycle() ；
2.作用域不一样，导致对象不能被垃圾回收器回收，比如： 	（1）非静态内部类会隐式地持有外部类的引用； 	（2）Context泄露； 概括一下，避免Context相关的内存泄露，记住以下事情：    	1、 不要保留对Context-Activity长时间的引用（对Activity的引用的时候，必须确保拥有和Activity一样的生命周期）；    	2、尝试使用Context-Application来替代Context-Activity 3、如果你不想控制内部类的生命周期，应避免在Activity中使用非静态的内部类，而应该使用静态的内部类，并在其中创建一个对Activity的弱引用；       这种情况的解决办法是使用一个静态的内部类，其中拥有对外部类的WeakReference； （3）Thread 引用其他对象也容易出现对象泄露； （4）onReceive方法里执行了太多的操作；
内存压力过大
（1）图片资源加载过多，超过内存使用空间，例如Bitmap 的使用；   	（2）重复创建view，listview应该使用convertview和viewholder；
如何避免内存泄露 	1.使用缓存技术，比如LruCache、DiskLruCache、对象重复并且频繁调用可以考虑对象池； 	2.对于引用生命周期不一样的对象，可以用软引用或弱引用SoftReferner WeakReferner； 	3.对于资源对象 使用finally 强制关闭； 	4.内存压力过大就要统一的管理内存；

差值器&估值器


进程间通信方式？


Volatile,synchronize,lock的原理


wait/notify


死锁的概念，怎么避免死锁
在两个或多个并发进程中，如果每个进程持有某种资源而又都等待别的进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁 ，通俗地讲，就是两个或多个进程被无限期地阻塞、相互等待的一种状态
死锁产生的原因主要是：  　　 1.系统资源不足  　　 2.进程推进顺序非法
产生死锁的必要条件：  　　（1）互斥（mutualexclusion），一个资源每次只能被一个进程使用  　　（2）不可抢占（nopreemption），进程已获得的资源，在未使用完之前，不能强行剥夺  　　（3）占有并等待（hold andwait），一个进程因请求资源而阻塞时，对已获得的资源保持不放  　　（4）环形等待（circularwait），若干进程之间形成一种首尾相接的循环等待资源关系。
避免死锁：
（1）破坏“互斥”条件:一般“互斥”条件是无法破坏的。因此，在死锁预防里主要是破坏其他三个必要条件，而不去涉及破坏“互斥”条件。
（2）破坏“请求和保持”条件:在系统中不允许进程在已获得某种资源的情况下，申请其他资源。即要想出一个办法，阻止进程在持有资源的同时申请其他资源。
（3）破坏“不可抢占”条件：允许对资源实行抢夺。 		方法一：如果占有某些资源的一个进程进行进一步资源请求被拒绝，则该进程必须释放它最初占有的资源，如果有必要，可再次请求这些资源和另外的资源。 		方法二：如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另一个进程，要求它释放资源。只有在任意两个进程的优先级都不相同的条件下，该方法才能预防死锁。
（4）破坏“循环等待”条件：将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序（升序）提出。这样做就能保证系统不出现死锁。
解除死锁：
（1）抢占资源。从一个或多个进程中抢占足够数量的资源，分配给死锁进程，以解除死锁状态。
（2）终止（或撤销）进程。终止（或撤销）系统中的一个或多个死锁进程，直至打破循环环路，使系统从死锁状态解脱出来。
总结：
写程序时应该尽量避免同时获得多个锁,如果一定有必要这么做,则有一个原则:如果所有线程在需要多个锁时都按相同的先后顺序(常见的是按Mutex变量的地址顺序)获得锁,则不会出现死锁。比如一个程序中用到锁1、锁2、锁3,它们所对应的Mutex变量的地址是锁1<锁2<锁3,那么所有线程在需要同时获得2个或3个锁时都应该按锁1、锁2、锁3的顺序获得。
如果要为所有的锁确定一个先后顺序比较困难,则应pthread_mutex_trylock调用代替pthread_mutex_lock 调用,以免死锁。


两个不重复的数组集合中，求共同的元素。

二叉树，给出根节点和目标节点，找出从根节点到目标节点的路径


TCP与UDP区别与应用（三次握手和四次挥手）涉及到部分细节（如client如何确定自己发送的消息被server收到）

### 断点续传的实现
