#### ANR引入的原因
要解决ANR问题首先需要了解ANR引入的原因。Android系统通过对应用进程的组件（Activity，Service，Receiver，Provider、input）的响应能力进行超时监控，如果超过预定时间应用进程还未完成任务，则会触发系统的ANR警告。 所以ANR引入的原因可以分为两大类
1.主线程繁忙，来不及处理关键消息：存在耗时消息、或者消息队列拥塞，关键消息得不到调度、或者发生死锁2.系统繁忙，主线程得不到调度：系统或应用内部其它线程或资源负载过高（高IO、内存频繁抖动），主线程调度被严重抢占
监控方案
1. 监听anr目录的变化
使用FileProvider监听 /data/anr/traces.txt 文件的变化，并捕获现场进行上报。不过Android 6.0以上版本系统文件权限收紧后，没有读取这个文件的权限。之前我们采用这个监控方案导致大量高版本设备ANR问题漏报。
2. 主线程超时监测
开启一个子线程定期post一个message到主线程，每隔一段时间（比如5秒）监测该message是否被消费掉，如果没有被处理，则说明主线程被卡住，可能发生了ANR，再通过系统服务获取当前进程的错误信息，判断是否有ANR发生。 但这个会存在大量漏报的情况，并且轮询的方案性能不佳。
3. 监听 SIGQUIT 信号
系统服务在触发ANR后，会发送一个SIGQUIT信号到应用进程来触发dump traces，在应用侧我们可以监听SIGQUIT信号来判断是否发生了ANR。为了排除其他进程的ANR导致的误报，需要再通过系统服务获取当前进程的错误信息，进一步过滤。 第3种方案准确率高，性能损耗小，也是业界目前主流APP采用监控方案。

#### 优化案例
在具备完善准确的监控排查能力之后，下面分享一些优化案例。

##### SharedPreference优化
* 在特定消息处，主线程等待sp apply队列持久化完成
* 主线程对sp commit
* 主线程阻塞等待sp加载数据完成

在线下测试mmkv与sp对比性能数据，发现mmkv可以比较完美的解决这三个问题。
